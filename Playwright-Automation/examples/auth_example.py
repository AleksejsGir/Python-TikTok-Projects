# -*- coding: utf-8 -*-

"""
Пример использования Playwright для сохранения состояния авторизации.

Этот скрипт демонстрирует:
- Авторизацию на сайте
- Сохранение состояния авторизации (cookies, localStorage и т.д.)
- Повторное использование сохраненного состояния

Зачем это нужно?
--------------
Часто при автоматизации нам нужно авторизоваться на сайте один раз, а потом
использовать эту авторизацию многократно. Без сохранения состояния пришлось бы
каждый раз заново вводить логин и пароль.
"""

# Импортируем необходимые библиотеки
from playwright.sync_api import sync_playwright  # Основная библиотека Playwright
import os  # Для работы с файловой системой (проверка существования файлов)
import json  # Для работы с JSON (сохранение и чтение состояния авторизации)

# Путь для сохранения состояния авторизации
# Это будет файл JSON, содержащий cookies, localStorage и другие данные сессии
AUTH_FILE = "auth_state.json"


def login_and_save_state(playwright):
    """
    Функция для авторизации на сайте и сохранения состояния сессии.

    Эта функция:
    1. Открывает страницу авторизации
    2. Позволяет пользователю вручную ввести логин и пароль
    3. Сохраняет состояние авторизации в файл для последующего использования

    Параметры:
    playwright -- объект Playwright, предоставляющий доступ к браузерам

    Возвращает:
    True, если авторизация прошла успешно и состояние сохранено
    False, если авторизация не удалась
    """
    # Запускаем браузер с видимым интерфейсом
    browser = playwright.chromium.launch(headless=False)

    # Создаем новый браузерный контекст
    # Контекст - это как отдельный профиль браузера с собственными cookies и хранилищем
    context = browser.new_context()

    # Открываем новую страницу в этом контексте
    page = context.new_page()

    # Переходим на страницу логина GitHub
    # GitHub используется как пример, так как это публичный сайт с авторизацией
    # В реальном сценарии вы бы использовали ваш целевой сайт
    page.goto("https://github.com/login")

    # Просим пользователя выполнить авторизацию вручную
    # Это полезно, когда:
    # 1. Сайт имеет сложную защиту от ботов (CAPTCHA, 2FA и т.д.)
    # 2. Вы не хотите хранить логин/пароль в коде
    print("Пожалуйста, авторизуйтесь на сайте вручную...")
    print("После успешной авторизации нажмите Enter в консоли")
    input()  # Ждем, пока пользователь нажмет Enter

    # Проверяем, успешно ли прошла авторизация
    # Если URL все еще начинается с адреса страницы логина,
    # значит, авторизация не удалась
    if page.url.startswith("https://github.com/login"):
        print("Авторизация не удалась")
        browser.close()
        return False

    print("Авторизация успешна, сохраняем состояние...")

    # Сохраняем состояние браузера в переменную
    # storage_state() возвращает словарь с cookies и localStorage
    storage = context.storage_state()

    # Записываем состояние в файл в формате JSON
    # Это позволит использовать его в будущих сессиях
    with open(AUTH_FILE, "w") as f:
        f.write(json.dumps(storage))

    # Делаем скриншот после авторизации для подтверждения успешного входа
    # Путь "../screenshots/" означает "папка screenshots в родительской директории"
    page.screenshot(path="../screenshots/after_login.png")

    # Закрываем браузер и освобождаем ресурсы
    browser.close()
    return True


def use_saved_state(playwright):
    """
    Функция для использования ранее сохраненного состояния авторизации.

    Эта функция:
    1. Запускает браузер с загрузкой сохраненного состояния
    2. Проверяет, сохранилась ли авторизация

    Параметры:
    playwright -- объект Playwright, предоставляющий доступ к браузерам
    """
    # Запускаем браузер с видимым интерфейсом
    browser = playwright.chromium.launch(headless=False)

    # Создаем контекст с загрузкой сохраненного состояния
    # Параметр storage_state указывает путь к файлу с сохраненными cookies и localStorage
    # Это автоматически "залогинит" нас на сайте без необходимости ввода логина и пароля
    context = browser.new_context(storage_state=AUTH_FILE)

    # Открываем новую страницу
    page = context.new_page()

    # Переходим на GitHub, где мы должны уже быть авторизованы
    # Если сохраненное состояние содержит валидные cookies,
    # сайт узнает нас и покажет персонализированную страницу
    page.goto("https://github.com/")

    # Делаем скриншот для проверки авторизации
    page.screenshot(path="../screenshots/using_saved_auth.png")

    print("Проверяем, сохранилась ли авторизация...")

    # Проверяем наличие элемента, доступного только для авторизованных пользователей
    # На GitHub таким элементом является аватар пользователя в шапке сайта
    try:
        # Находим аватар пользователя с помощью CSS-селектора
        avatar = page.locator("summary.Header-link img.avatar")

        # Проверяем, найден ли элемент
        # count() возвращает количество найденных элементов
        if avatar.count() > 0:
            print("Авторизация сохранилась успешно!")
        else:
            print("Не удалось подтвердить сохранение авторизации")
    except Exception as e:
        # Если произошла ошибка при поиске элемента, выводим информацию об ошибке
        print(f"Ошибка при проверке авторизации: {e}")

    # Ждем, пока пользователь нажмет Enter, чтобы завершить программу
    # Это дает время пользователю увидеть результат в браузере
    input("Нажмите Enter для завершения...")

    # Закрываем браузер и освобождаем ресурсы
    browser.close()


# Основной блок кода
with sync_playwright() as playwright:
    # Проверяем, существует ли файл с сохраненным состоянием
    if not os.path.exists(AUTH_FILE):
        # Если файла нет, запускаем процесс авторизации и сохранения состояния
        if login_and_save_state(playwright):
            print(f"Состояние авторизации сохранено в файл {AUTH_FILE}")
    else:
        # Если файл уже существует, используем сохраненное состояние
        print(f"Используем сохраненное состояние из файла {AUTH_FILE}")
        use_saved_state(playwright)

# Советы и рекомендации:
#
# 1. Безопасность:
#    - Не храните пароли в коде или в репозитории
#    - Файл с состоянием авторизации также может содержать конфиденциальную информацию,
#      не включайте его в систему контроля версий (добавьте AUTH_FILE в .gitignore)
#
# 2. Срок действия:
#    - Cookies и токены авторизации имеют ограниченный срок действия
#    - Если сохраненное состояние перестало работать, удалите файл AUTH_FILE
#      и запустите скрипт заново для создания нового состояния
#
# 3. Альтернативные подходы:
#    - Вместо ручного ввода логина/пароля можно автоматизировать весь процесс
#    - Для этого храните учетные данные в переменных окружения или конфигурационном файле
#    - Пример:
#      ```
#      page.fill('input#login_field', os.environ.get('GITHUB_USERNAME'))
#      page.fill('input#password', os.environ.get('GITHUB_PASSWORD'))
#      page.click('input[type="submit"]')
#      ```